
# 其他概念
**Key words**: 
**闭包**、**高阶函数**、**递归**、**尾递归**、 **蹦床**

### 高阶函数
函数当参数，或者当返回值，达到更高程度的抽象。
这是一等公民的体现。

### 闭包
当一个函数调用结束，栈上的调用帧被释放，但是堆上的作用域并不被释放。
通俗的说就是，栈的引用丢了，但是真正的函数对象还在，函数对象在的话，内部的的变量就还在，这些变量可能还会用的到。我们需要用一些技术手段拿到这些变量。
这就是闭包要做的事情。

```js
function outer(p) { 
  function inner(base) {
    return Math.pow(base, p);
    }
  return inner;
}
var square = outer(2); 
square(3); // 9
```
闭包借用高阶函数实现对内部属性的访问。上面的例子中，外层函数的参数power实际上就是一个在外层函数中声明的变量，正常情况下，当我们调用完了outter，参数p是无法再被拿到的。
但是inner函数本来就能访问外层函数的作用域上的属性，所以，闭包这种技术手段就是这样，用外层函数return 出一个能访问到其变量的内层函数。
 
### 递归
这很显然是一个递归：
```js
function sum(n) { 
  if (n === 1) return 1; 
  return n + sum(n - 1); 
}
```
假设现在要执行sum(5),会发生什么事情？
```
(5 + sum(4)) 
(5 + (4 + sum(3))) 
(5 + (4 + (3 + sum(2)))) 
(5 + (4 + (3 + (2 + sum(1))))) 
(5 + (4 + (3 + (2 + 1)))) 
(5 + (4 + (3 + 3))) 
(5 + (4 + 6)) 
(5 + 10) 
15

```
普通递归时，内存需要记录调用的堆栈所出的深度和位置信息。在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。在cpu计算和内存会消耗很多，而且当深度过大时，会出现溢出(调用栈溢出)。
这个问题需要一些优化技巧来解决。

#### 尾递归
我们将上面的函数改下如下：
```js
function sum(x, total) { 
  if (x === 1) { 
    return x + total; 
  } 
  return sum(x - 1, x + total); 
}
```
这个函数在最开始调用时候是sum(5, 0), 他的执行过程如下：
```
sum(5, 0) 
sum(4, 5) 
sum(3, 9) 
sum(2, 12) 
sum(1, 14)
```
如果真的是这样，那么我们的代码是被优化了。
所以什么是尾递归？
1. 尾递归是在函数执行的最后异步调用的是自身，并非是在最后一行调用自身；
2. 据说浏览器底层没有做真正的尾递归优化？？（就是还是会栈溢出），不做优化的原因是丢失堆栈信息无法追踪bug？

#### 蹦床函数

递归执行起来就是一个循环，我们把尾递归函数可以显示的让它循环起来。
有一种技术叫，蹦床函数：
```js

function trampoline(func, a) {
  let result = func.call(func, a);
  while (typeof result === 'function') {
    result = result();
  }
  return result;
}

```
最终这样使用：
```js
const val = trampoline(sum, 6)
console.log(val)

```
